# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W970PbWuy9axDI-kl6JvTnCB0BjfrMH5
"""

#!/usr/bin/python

import torch
import torch.nn as nn
import torchvision.transforms as transforms
from torch.utils.data import DataLoader

import encoder 
import generator
import discriminator
import STL10GrayColor as STLGray
import utils as utls


device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

#data
transform = transforms.Compose([transforms.Resize(224)])#,
#                                transforms.ToTensor()])

# Load STL10 dataset
stl10_trainset = STLGray.STL10GrayColor(root="./data",
                              split='train',
                              download=True,
                              transform=transform)

# Parameters
params_loader = {'batch_size': 32,
               'shuffle': False}

train_loader = DataLoader(stl10_trainset, **params_loader)

encoder = encoder.Encoder()
decoder = generator.Generator()

loss_func = nn.MSELoss()
optimizer = torch.optim.Adam(encoder.parameters(), lr=0.0001)

class Demultiplier(nn.Module):
    """converts 1 channel to 3"""
    # o = [(i + 2p -k)/s + 1]

    def __init__(self):
        super(Demultiplier, self).__init__()
        self.conv = nn.Sequential(
            nn.Conv2d(in_channels=1, out_channels=3, kernel_size=(3,3), padding=1))
    
    def forward(self, x):
        print(torch.unsqueeze(x, 1).shape)
        x = torch.unsqueeze(x,1)
        out = self.conv(x)
        return out
    
demultiplier = Demultiplier()

import numpy as np

for batch_index, (image_g, image_c) in enumerate(train_loader):


    image_g = demultiplier(image_g)

    print('Demultiplied')
    
    optimizer.zero_grad()
        
    output = encoder(image_g)

    print('encoded')
    print(output.shape)
    
    output = decoder(output)
    
    print('decoded')
    print(output.shape)

    break





